#final语义
与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：

- 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（**写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。**）
- 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。**（在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。）**



如果final域是引用类型：还会加上一条限制

- 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。(**这条规则保证了在对象引用为任意线程可见之前，对象的final引用的成员域已经被初始化过了！！**)

##JSR-133修复final语义的意义

通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。



##JMM的设计

从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：
[![CjRX9A.png](https://s1.ax1x.com/2018/06/15/CjRX9A.png)](https://imgchr.com/i/CjRX9A)

 - 程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。
 - 编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。

由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。

>happen-before规则 是JSR专家组为了帮助 java 程序员避免学习复杂的底层硬件知识，对写出正确同步的程序的一个简易指南！！！


[![CjRj1I.png](https://s1.ax1x.com/2018/06/15/CjRj1I.png)](https://imgchr.com/i/CjRj1I)


因此，JMM把happens- before要求禁止的重排序分为了下面两类：

- 会改变程序执行结果的重排序。
- 不会改变程序执行结果的重排序。

JMM对这两种不同性质的重排序，采取了不同的策略：

- 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。
- 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。

##JMM的内存可见性保证

Java程序的内存可见性保证按程序类型可以分为下列三类：

- 单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
- 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
- 未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。

下图展示了这三类程序在JMM中与在顺序一致性内存模型中的执行结果的异同：


[![CjRLhd.png](https://s1.ax1x.com/2018/06/15/CjRLhd.png)](https://imgchr.com/i/CjRLhd)