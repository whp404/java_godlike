#JAVA（JMM）内存模型


###什么是顺序一致性模型：

 - 顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：

	
   - 一个线程中的所有操作必须按照程序的**顺序**来执行。
   - （不管程序是否同步）**所有线程都只能看到一个单一的操作执行顺序**。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

![CjVDSg.png](https://s1.ax1x.com/2018/06/14/CjVDSg.png)


>这个模型最重要的一点就是：如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同，**所以这个模型就是帮助程序员 更加容易的预测 java 内存模型的同步结果！！**这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。

- 还有一点需要强调的是：未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到**一个一致的整体执行顺序**。在这一点上，但是，**在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的**，而且所有线程看到的操作执行顺序也可能不一致。



未同步程序在这两个模型中的执行特性有下面几个差异

<table>
        <tr>
            <th>顺序一致性模型</th>
            <th>顺序一致性模型保证单线程内的操作会按程序的顺序执行</th>
            <th>顺序一致性模型保证所有线程只能看到一致的操作执行顺序</th>
            <th>顺序一致性模型保证对所有的内存读/写操作都具有原子性。</th>
        </tr>
        <tr>
            <th>JMM</th>
            <th>而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）</th>
            <th>JMM不保证所有线程能看到一致的操作执行顺序</th>
            <th>JMM不保证对64位的long型和double型变量的读/写操作具有原子性</th>
        </tr>   
    </table>


##volatile关键字的理解

简而言之，volatile变量自身具有下列特性：

- 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

需要注意的是第二点，对于64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。**因为对于volatile++这种语句，实际上是分为三条语句执行的！**

##volatile写-读的内存语义
volatile写的内存语义如下：

* 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。

volatile读的内存语义如下：

- 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

##volatile内存语义的实现
插入内存屏障，而且为了保证各个平台上表现一致，对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：

    在每个volatile写操作的前面插入一个StoreStore屏障。
    在每个volatile写操作的后面插入一个StoreLoad屏障。
    在每个volatile读操作的后面插入一个LoadLoad屏障。
    在每个volatile读操作的后面插入一个LoadStore屏障。

##JSR133做了啥？
旧的Java内存模型允许volatile变量与普通变量之间重排序。JSR-133专家组决定增强volatile的内存语义**：严格限制编译器和处理器对volatile变量与普通变量的重排序，**确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。

由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对**整个临界区代码的执行具有原子性**。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。

>所以说锁在保证可见性的同时，还保持了互斥执行！！！比如volatile++这种操作，不具有原子性，但放到同步方法里，就可原子 和 互斥性！更加强大


